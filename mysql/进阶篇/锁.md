## 1.概述
MySQL中的锁，按照锁的粒度分，分为以下三类：
+ 全局锁：锁定数据库中的所有表。 
+ 表级锁：每次操作锁住整张表。
+ 行级锁：每次操作锁住对应的行数据。

## 2.全局锁
### 2.1介绍
全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。
### 2.2语法
#### 加全局锁
```mysql
flush tables with read lock ;
```


#### 数据备份 
数据备份的相关指令, 在后面MySQL管理章节, 还会详细讲解. 
```
mysqldump -uroot –p1234 itcast > itcast.sql;
```

#### 释放锁
```mysql
unlock tables;
```
### 2.3特点
全局锁会存在以下问题:
+ 如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。
+ 如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。
在InnoDB引擎中，我们可以在备份时加上参数 --single-transaction 参数来完成不加锁的一致 性数据备份。
```mysql
mysqldump --single-transaction -uroot –p123456 itcast > itcast.sql
```

## 3.表级锁
### 3.1介绍
表级锁应用在MyISAM、 InnoDB、BDB等存储引擎中。
主要分为以下三类:
+ 表锁 
+ 元数据锁（meta data lock，MDL） 
+ 意向锁
### 3.2 表锁
表锁分为两类
+ 加锁：lock tables 表名... read/write。 
+ 释放锁：unlock tables / 客户端断开连接 。
### 3.3元数据锁
meta data lock , 元数据锁，简写MDL。

### 3.4意向锁
#### 3.4.1介绍
为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行 数据是否加锁，使用意向锁来减少表锁的检查。
#### 3.4.2分类
+ 意向共享锁(IS): 由语句select ... lock in share mode添加 。 与 表锁共享锁 (read)兼容，与表锁排他锁(write)互斥。 
+ 意向排他锁(IX): 由insert、update、delete、select...for update添加 。与表锁共 享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。
```一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。```

可以查看意向锁以及行锁的加锁情况:
```mysql
select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;
```

## 4.行级锁
### 4.1介绍
行级锁，每次操作锁住对应的行数据锁定粒度最小发生锁冲突的概率最低并发度最高。应用在 InnoDB存储引擎中。InnoDB的数据是基于索引组织的行锁是通过对索引上的索引项加锁来实现的而不是对记录加的锁。对于行级锁，主要分为以下三类：
#### 行锁（Record Lock）
锁定单个行记录的锁，防止其他事务对此行进行update和delete。在 RC、RR隔离级别下都支持。锁定索引记录间隙（不含该记录）确保索引记录间隙不变防止其他事 务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。
#### 间隙锁（Gap Lock）
锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事 务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。
#### 临键锁（Next-Key Lock）
行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。 在RR隔离级别下支持。

### 4.2行锁
### 4.2.1 介绍
innodb实现了以下两种类型的行锁
共享锁

