## 1.概述
MySQL中的锁，按照锁的粒度分，分为以下三类：
+ 全局锁：锁定数据库中的所有表。 
+ 表级锁：每次操作锁住整张表。
+ 行级锁：每次操作锁住对应的行数据。

## 2.全局锁
### 2.1介绍
全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。
### 2.2语法
#### 加全局锁
```mysql
flush tables with read lock ;
```


#### 数据备份 
数据备份的相关指令, 在后面MySQL管理章节, 还会详细讲解. 
```
mysqldump -uroot –p1234 itcast > itcast.sql;
```

#### 释放锁
```mysql
unlock tables;
```
### 2.3特点
全局锁会存在以下问题:
+ 如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。
+ 如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。
在InnoDB引擎中，我们可以在备份时加上参数 --single-transaction 参数来完成不加锁的一致 性数据备份。
```mysql
mysqldump --single-transaction -uroot –p123456 itcast > itcast.sql
```

## 3.表级锁
### 3.1介绍
表级锁应用在MyISAM、 InnoDB、BDB等存储引擎中。
主要分为以下三类:
+ 表锁 
+ 元数据锁（meta data lock，MDL） 
+ 意向锁
### 3.2 表锁
#### 表共享读锁
本地客户端和其他客户端都只能进行读取操作
#### 表独占写锁
本地客户端读写俊不受影响 ,其他客户端无法读或写

+ 加锁：lock tables 表名... read/write。 (读锁or写锁)
+ 释放锁：unlock tables / 客户端断开连接 。
### 3.3元数据锁
+ meta data lock , 元数据锁，简写MDL。
+ 在访问一张表的时候会自动加上，**避免DML与DDL冲突，保证读写的正确性**
![[../图片存储/Pasted image 20230613133316.png]]
共享锁之间是相互兼容的，例如，在客户端A开启事务，进行select操作，在客户端B开启事务，执行update操作，是不会有冲突的。

```mysql
-- 查看数据库中元数据锁的情况
select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks ;
```

### 3.4意向锁
#### 3.4.1介绍
为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行 数据是否加锁，使用意向锁来减少表锁的检查。
#### 3.4.2分类
+ 意向共享锁(IS): 由语句select ... lock in share mode添加 。 与 表锁共享锁 (read)兼容，与表锁排他锁(write)互斥。 
+ 意向排他锁(IX): 由insert、update、delete、select...for update添加 。与表锁共 享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。
```一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。```

可以查看意向锁以及行锁的加锁情况:
```mysql
select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;
```

## 4.行级锁
### 4.1介绍
行级锁，每次操作锁住对应的行数据锁定粒度最小发生锁冲突的概率最低并发度最高。应用在 InnoDB存储引擎中。InnoDB的数据是基于索引组织的行锁是通过对索引上的索引项加锁来实现的而不是对记录加的锁。对于行级锁，主要分为以下三类：
#### 行锁（Record Lock）
锁定单个行记录的锁，防止其他事务对此行进行update和delete。在 RC、RR隔离级别下都支持。锁定索引记录间隙（不含该记录）确保索引记录间隙不变防止其他事 务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。
#### 间隙锁（Gap Lock）
锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。
#### 临键锁（Next-Key Lock）
行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。 在RR隔离级别下支持。

### 4.2行锁
#### 4.2.1 介绍
innodb实现了以下两种类型的行锁
+ 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。
+ 排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他。
![[../../Pasted image 20230613141832.png]]
##### 常见的SQL语句所加的锁
![[../图片存储/Pasted image 20230612173920.png]]

#### 4.2.2演示
默认情况下，InnoDB在 **REPEATABLE READ** 事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。
+ 针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。 InnoDB的行
+ 锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁。<font color = "rgb(0,0,0)">更新没有索引的数据，行锁升级表锁</font>
可以查看意向锁与行锁的加锁情况
```mysql
select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;
```

#### 4.2.3 间隙锁
+ 索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。 
+ 索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。
+ 索引上的范围查询(唯一索引) --会访问到不满足条件的第一个值为止。

注意：间隙锁的唯一目的是防止其他事物插入间隙。间隙锁可以共存，一个事物采用的间隙锁不会             阻止另一个事物在同一间隙上采用间隙锁


## 5.事务管理
### 5.1事务基础
#### 事务
事务是一组操作的集合，它是一个不可分割的工作单位事务会把所有的操作作为一个整体一起向系 统提交或撤销操作请求，即这些操作要么同时成功要么同时失败。

#### 特性
+ 原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。
+  一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。 
+ 隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环 境下运行。
+ 持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。

那实际上，我们研究事务的原理，就是研究MySQL的InnoDB引擎是如何保证事务的这四大特性的。

### 5.2redo log

### 5.3undo log

## 6.InnoDB引擎
### 6.1 逻辑存储结构
InnoDB的逻辑存储结构如下

![[../图片存储/Pasted image 20230613200311.png]]
#### 1. 表空间(tablespace)
表空间是InnoDB存储引擎逻辑结构的最高层， 如果用户启用了参数 innodb_file_per_table(在 8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可以对应多个表空 间，用于存储记录、索引等数据。

#### 2.段（segment）
段分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段 （Rollback segment）、InnoDB是索引组织表，数据段就是B+树的叶子节点，索引段即为B+树的 非叶子节点。段用来管理多个Extent（区）。
#### 3.区（extant）
区，表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一 个区中一共有64个连续的页。
#### 4.页（page）
页，是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性， InnoDB 存储引擎每次从磁盘申请 4-5 个区。
#### 5.行（row）
行，InnoDB 存储引擎数据是按行进行存放的。
在行当中，有两个隐藏的字段
+ Trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。
+ Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个 隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。


## 6.2 架构
### 6.2.1 概述
MySQL5.5 版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发 中使用非常广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构
![[../图片存储/Pasted image 20230613200748.png]]

### 6.2.2内存结构
![[../图片存储/Pasted image 20230613200808.png]]

在左侧的内存结构中，主要分为这么四大块儿： Buffer Pool、Change Buffer、Adaptive Hash Index、Log Buffer。 接下来介绍一下这四个部分
#### 1.Buff Pool
InnoDB 存储引擎基础磁盘文件存储，访问物理硬盘和在内存当中进行访问，速度的相差很大，为了进口可能弥补这两者之间的I/o效率的插值，就需吧经常使用的数据加载到缓冲池当中，避免每次访问都进行磁盘的I/O。

在InoDB的缓冲池当中不仅缓存的索引的页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及InnoDB的锁信息等等。

缓冲池 Buffer Pool，是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在实行增删改查的操作的时候，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定的频率刷新到磁盘，从而减少磁盘的IO，加快处理的速度。

缓冲池以page为单位，底层采用链表数据结构管理page。根据状态，将page分为三种类型
+ free page ：空闲page，未被使用。
+ clean page ：被使用的page，数据没有被修改过。
+ dirty oage：脏页，被使用page，数据被修改过，也中数据与磁盘的数据产生了不一致
在专用的服务器上，通常将多达80%的物理内存分配给缓冲池。参数设置：shhow baribles like ‘innodb_buffer_pool_size’;

#### 2.Chang Buffe
Chang Buffef，更改缓冲区（针对于非唯一二级索引页），在执行DML语句时，如果这些数据page没有在buffer pool 中，不会直接操作磁盘，二回将数据变更存在更改缓冲区change buffer 中，在未来数据被读取时，再将数据合并回复到buffer pool中，再讲合并后的数据刷新到磁盘中。






